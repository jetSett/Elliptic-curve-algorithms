use std::fmt;

use std::fmt::Display;

use crate::field::{Field};

pub mod fp_elliptic_curves;

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum ProjKPoint<K> {
    FinPoint(K, K),
    InfPoint,
}

impl<K> fmt::Display for ProjKPoint<K>
    where K : fmt::Display{
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            use ProjKPoint::*;
            match self {
                FinPoint(x, y) => write!(f, "FP: ({}, {})", x, y),
                InfPoint => write!(f, "Inf P"),
            }
        }
}


// y^2 + a_1 xy + a_3 y = x^3 + a_2 x^2 + a_4 x + a_6
#[derive(Debug, PartialEq, Clone)]
pub struct EllipticCurve<K> {
    pub a_1: K,
    pub a_3: K,

    pub a_2: K,
    pub a_4: K,
    pub a_6: K,
}


impl<K> Display for EllipticCurve<K> where K : Field + Display{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_reduced_weierstrass(){
            write!(f, "y^2 = x^3 + {}*x + {}", self.a_4, self.a_6)
        }else{
            write!(f, "y^2 + {}*xy + {}*y = x^3 + {}*x^2 + {}*x + {}", self.a_1, self.a_3, self.a_2, self.a_4, self.a_6)
        }
    }
}

impl<K> EllipticCurve<K> 
    where K : Field{
        // y^2 = x^3 + a*x + b
        pub fn new_reduced_weierstrass(a: K, b: K) -> EllipticCurve<K>{
            EllipticCurve::<K>{
                a_1: K::from_int(0),
                a_3: K::from_int(0),

                a_2: K::from_int(0),
                a_4: a,
                a_6: b,
            }
        }

        pub fn is_reduced_weierstrass(&self) -> bool{
            self.a_1 == K::from_int(0) && self.a_2 == K::from_int(0) && self.a_3 == K::from_int(0)
        }

        pub fn to_reduced_weierstrass(self) -> EllipticCurve<K>{
            EllipticCurve::new_reduced_weierstrass(-K::from_int(27)*self.c4(), -K::from_int(54)*self.c6())
        }

        // Return the curve quotiented by the subgroup generated by p
        pub fn velu_curve(&self, p : &ProjKPoint<K>) -> EllipticCurve<K>{
            if !self.is_reduced_weierstrass(){
                panic!("VELU formula must be used only with curves in reduced form");
            }
            let mut g = p.clone();
            let a = self.a_4.clone();
            let b = self.a_6.clone();
            let mut sum_a = K::from_int(0);
            let mut sum_b = K::from_int(0);
            while let ProjKPoint::FinPoint(x_g, _) = &g {
                sum_a += K::from_int(3)*x_g.clone()*x_g.clone() + a.clone();
                sum_b += K::from_int(5)*x_g.clone()*x_g.clone()*x_g.clone() + K::from_int(3)*a.clone()*x_g.clone() + K::from_int(2)*b.clone();
                g = self.add_points(g, p.clone());
            }
            EllipticCurve::new_reduced_weierstrass(a - K::from_int(5)*sum_a, b - K::from_int(7)*sum_b)
        }

        // Send the point q to the VELU curve of p
        pub fn velu_projection(&self, p : &ProjKPoint<K>, q : ProjKPoint<K>) -> ProjKPoint<K>{
            if !self.is_reduced_weierstrass(){
                panic!("VELU formula must be used only with curves in reduced form");
            }

            use ProjKPoint::*;
            match q.clone(){
                InfPoint => InfPoint,
                FinPoint(xq, yq) => {
                    let mut x = xq;
                    let mut y = yq;
                    let mut group_point = p.clone();
                    let mut q_plus_ip = self.add_points(p.clone(), q.clone());

                    while let FinPoint(x_ip, y_ip) = group_point.clone() {

                        if &group_point == &q{ // If Q == iP then Q is in the subgroup
                            return InfPoint;
                        }
                        if let FinPoint(x_q_plus_ip, y_q_plus_ip) = q_plus_ip.clone(){
                            x += x_q_plus_ip - x_ip;
                            y += y_q_plus_ip - y_ip;
                        }else{ // If Q + iP == 0 then Q is in the subgroup
                            return InfPoint;
                        }
                        group_point = self.add_points(group_point, p.clone());
                        q_plus_ip = self.add_points(q_plus_ip, p.clone());
                    }
                    FinPoint(x, y)
                }
            }
        }

        fn b2(&self) -> K{
            self.a_1.clone()*self.a_1.clone() + K::from_int(4)*self.a_2.clone()
            // self.a_1*self.a_1 + K::from_int(4)*self.a_4 // Version from Silvermann
        }

        fn b4(&self) -> K{
            K::from_int(2)*self.a_4.clone() + self.a_1.clone()*self.a_3.clone()
        }

        fn b6(&self) -> K{
            self.a_3.clone()*self.a_3.clone() + K::from_int(4)*self.a_6.clone()
        }

        fn c4(&self) -> K{
            let b2 = self.b2();
            let b4 = self.b4();

            b2.clone()*b2 - K::from_int(24)*b4
        }

        fn c6(&self) -> K{
            let b2 = self.b2();
            let b4 = self.b4();
            let b6 = self.b6();

            -b2.clone()*b2.clone()*b2.clone() + K::from_int(36)*b2*b4 - K::from_int(216)*b6
        }

        pub fn j_invariant(&self) -> K{
            let c4 = self.c4();
            c4.clone()*c4.clone()*c4/self.discriminant()
        }

        pub fn discriminant(&self) -> K{
            let b2 = self.b2();
            let b4 = self.b4();
            let b6 = self.b6();

            K::from_int(-4)*(b2.clone()*b2.clone()*b2.clone()*b6.clone() - b2.clone()*b2.clone()*b4.clone()*b4.clone() - 
            K::from_int(36)*b2*b4.clone()*b6.clone() + K::from_int(32)*b4.clone()*b4.clone()*b4 + K::from_int(108)*b6.clone()*b6)
            //-b2*b2*b8 - K::from_int(8)*b4*b4*b4 - K::from_int(27)*b6*b6 + K::from_int(9)*b2*b4*b6
        }

        pub fn is_on_curve(&self, point : &ProjKPoint<K>) -> bool{
            use ProjKPoint::*;
            // y^2 + a_1 xy + a_3 y = x^3 + a_2 x^2 + a_4 x + a_6
            match point{
                InfPoint => true,
                FinPoint(x, y) =>{
                    y.clone()*y.clone() + self.a_1.clone()*x.clone()*y.clone() + self.a_3.clone() * y.clone() == 
                    x.clone()*x.clone()*x.clone() + self.a_2.clone()*x.clone()*x.clone() + self.a_4.clone()*x.clone() + self.a_6.clone()
                }
            }
        }

        pub fn neg_point(&self, point : ProjKPoint<K>) -> ProjKPoint<K>{
            assert!(self.is_on_curve(&point));
            use ProjKPoint::*;
            match point {
                InfPoint => InfPoint,
                FinPoint(x, y) => FinPoint(x.clone(), -y - self.a_1.clone()*x - self.a_3.clone()),
            }
        }

        pub fn add_points(&self, point1 : ProjKPoint<K>, point2 : ProjKPoint<K>) -> ProjKPoint<K>{
            assert!(self.is_on_curve(&point1));
            assert!(self.is_on_curve(&point2));

            use ProjKPoint::*;

            let a_1 = self.a_1.clone();
            let a_2 = self.a_2.clone();
            let a_3 = self.a_3.clone();
            let a_4 = self.a_4.clone();
            let a_6 = self.a_6.clone();

            if point1 == self.neg_point(point2.clone()){
                return InfPoint;
            }
            match (point1.clone(), point2.clone()){
                (InfPoint, _) => point2,
                (_, InfPoint) => point1,
                (FinPoint(x1, y1), FinPoint(x2, y2)) => {
                    let (lambda, nu) = 
                        if x1 != x2 {
                            ((y2.clone()-y1.clone())/(x2.clone()-x1.clone()), (y1*x2.clone() - y2*x1.clone())/(x2.clone()-x1.clone()))
                        }else{
                            ((K::from_int(3)*x1.clone()*x1.clone() + K::from_int(2)*a_2.clone()*x1.clone() + a_4.clone() - a_1.clone()*y1.clone())/
                             (K::from_int(2)*y1.clone() + a_1.clone()*x1.clone() + a_3.clone()), 

                             (-x1.clone()*x1.clone()*x1.clone() + a_4*x1.clone() + K::from_int(2)*a_6 - a_3.clone()*y1.clone())/
                             (K::from_int(2)*y1 + a_1.clone()*x1.clone() + a_3.clone()))
                        };
                    let x3 = lambda.clone()*lambda.clone() +a_1.clone()*lambda.clone() - a_2 - x1 - x2;
                    let y3 = -(lambda + a_1)*x3.clone() - nu - a_3;
                    FinPoint(x3, y3)
                }
            }
        }

        pub fn scalar_mult(&self, n : K::Integer, point : ProjKPoint<K>) -> ProjKPoint<K>{

            assert!(self.is_on_curve(&point));
            if n == K::Integer::from(0){
                return InfPoint;
            }

            if n < K::Integer::from(0){
                return self.scalar_mult(-n, self.neg_point(point));
            }

            use ProjKPoint::*;
            let mut p1 = point;
            let mut p2 = self.add_points(p1.clone(), p1.clone());

            let mut logm = 0;
            let mut m = n.clone();
            while m != K::Integer::from(0){
                m >>= 1;
                logm += 1;
            }
            logm -= 1; // -1 is here in order to ignore the first bit (included in p2 already)

            while logm >= 1{
                let bit = (n.clone()&(K::Integer::from(1)<<(logm-1)))>>(logm-1); // the current bit
                logm -= 1;
                if bit == K::Integer::from(0){
                    p2 = self.add_points(p1.clone(), p2);
                    p1 = self.add_points(p1.clone(), p1);
                }else{
                    p1 = self.add_points(p1, p2.clone());
                    p2 = self.add_points(p2.clone(), p2);
                }
            }
            p1
        }
}

#[cfg(test)]
mod test;